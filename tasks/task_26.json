{
  "task_id": "Custom/Parser/ExpressionEvaluator",
  "prompt": "def evaluate_expression(expr, variables):\n    \"\"\"\n    Expression Evaluator with Variables and Standard Operators\n\n    Evaluate a mathematical expression with variables and standard operators.\n\n    The expression can contain:\n    - Integer numbers (positive and negative)\n    - Variables (lowercase letters, looked up in the variables dict)\n    - Standard operators: +, -, *, /, % with normal precedence\n    - Parentheses for grouping\n\n    Operator Precedence (high to low):\n    - *, /, % (precedence 2) - evaluated first\n    - +, - (precedence 1) - evaluated last\n    - Operators with equal precedence are evaluated left-to-right\n    - Parentheses override precedence\n\n    Args:\n        expr: str - the expression to evaluate (e.g., \"3 + x * 2\")\n        variables: dict - maps variable names to their integer values\n                         (e.g., {'x': 5, 'y': 10})\n\n    Returns:\n        int - the result of evaluating the expression\n\n    Example 1:\n        expr = \"3 + 4 * 2\"\n        variables = {}\n        Result: 11  (because * has higher precedence: 3 + (4*2) = 3 + 8 = 11)\n\n    Example 2:\n        expr = \"(3 + 4) * 2\"\n        variables = {}\n        Result: 14  (parentheses override: (3+4) * 2 = 7 * 2 = 14)\n\n    Example 3:\n        expr = \"x + y * 2\"\n        variables = {'x': 10, 'y': 5}\n        Result: 20  (10 + (5*2) = 10 + 10 = 20)\n\n    Example 4:\n        expr = \"10 - 3 - 2\"\n        variables = {}\n        Result: 5  (left-to-right: (10-3) - 2 = 7 - 2 = 5)\n\n    Example 5:\n        expr = \"20 / 4 / 2\"\n        variables = {}\n        Result: 2  (left-to-right: (20/4) / 2 = 5 / 2 = 2, integer division)\n\n    Example 6:\n        expr = \"17 % 5 + 3\"\n        variables = {}\n        Result: 5  (17 % 5 = 2, then 2 + 3 = 5)\n\n    Example 7:\n        expr = \"((2 + 3) * (4 + 1))\"\n        variables = {}\n        Result: 25  ((5) * (5) = 25)\n\n    Notes:\n    - Whitespace in expressions should be ignored\n    - Variable names are single lowercase letters (a-z)\n    - All arithmetic is integer arithmetic (/ is integer division)\n    - You can assume the expression is valid (balanced parentheses, defined vars)\n    \"\"\"\n",
  "entry_point": "evaluate_expression",
  "canonical_solution": "    expr = expr.replace(' ', '')\n    \n    operators = {\n        '+': (1, lambda a, b: a + b),\n        '-': (1, lambda a, b: a - b),\n        '*': (2, lambda a, b: a * b),\n        '/': (2, lambda a, b: a // b),\n        '%': (2, lambda a, b: a % b)\n    }\n    \n    def tokenize(s):\n        tokens = []\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                j = i\n                while j < len(s) and s[j].isdigit():\n                    j += 1\n                tokens.append(('NUM', int(s[i:j])))\n                i = j\n            elif s[i].islower():\n                tokens.append(('VAR', s[i]))\n                i += 1\n            elif s[i] == '(':\n                tokens.append(('LPAREN', '('))\n                i += 1\n            elif s[i] == ')':\n                tokens.append(('RPAREN', ')'))\n                i += 1\n            elif s[i] == '-' and (not tokens or tokens[-1][0] in ('LPAREN', 'OP')):\n                j = i + 1\n                while j < len(s) and s[j].isdigit():\n                    j += 1\n                tokens.append(('NUM', int(s[i:j])))\n                i = j\n            elif s[i] in operators:\n                tokens.append(('OP', s[i]))\n                i += 1\n            else:\n                i += 1\n        return tokens\n    \n    def parse_expr(tokens, pos, min_prec):\n        left, pos = parse_primary(tokens, pos)\n        while pos < len(tokens) and tokens[pos][0] == 'OP':\n            op = tokens[pos][1]\n            prec, func = operators[op]\n            if prec < min_prec:\n                break\n            pos += 1\n            right, pos = parse_expr(tokens, pos, prec + 1)\n            left = func(left, right)\n        return left, pos\n    \n    def parse_primary(tokens, pos):\n        token = tokens[pos]\n        if token[0] == 'NUM':\n            return token[1], pos + 1\n        elif token[0] == 'VAR':\n            return variables[token[1]], pos + 1\n        elif token[0] == 'LPAREN':\n            val, pos = parse_expr(tokens, pos + 1, 0)\n            return val, pos + 1\n        return 0, pos\n    \n    tokens = tokenize(expr)\n    result, _ = parse_expr(tokens, 0, 0)\n    return result\n",
  "test": "\n\nMETADATA = {\n    'author': 'custom',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    # Test 1: Basic precedence\n    assert candidate(\"3 + 4 * 2\", {}) == 11\n    \n    # Test 2: Parentheses override\n    assert candidate(\"(3 + 4) * 2\", {}) == 14\n    \n    # Test 3: Variables\n    assert candidate(\"x + y * 2\", {'x': 10, 'y': 5}) == 20\n    \n    # Test 4: Left-to-right same precedence\n    assert candidate(\"10 - 3 - 2\", {}) == 5\n    \n    # Test 5: Division\n    assert candidate(\"20 / 4 / 2\", {}) == 2\n    \n    # Test 6: Modulo\n    assert candidate(\"17 % 5 + 3\", {}) == 5\n    \n    # Test 7: Nested parentheses\n    assert candidate(\"((2 + 3) * (4 + 1))\", {}) == 25\n    \n    # Test 8: Single number\n    assert candidate(\"42\", {}) == 42\n    \n    # Test 9: Single variable\n    assert candidate(\"x\", {'x': 7}) == 7\n    \n    # Test 10: Complex expression\n    assert candidate(\"2 + 3 * 4 - 5\", {}) == 9\n    \n    # Test 11: All same precedence\n    assert candidate(\"10 + 5 - 3 + 2\", {}) == 14\n    \n    # Test 12: Mixed with variables\n    assert candidate(\"a * b + c / d\", {'a': 6, 'b': 3, 'c': 10, 'd': 2}) == 23\n\n"
}

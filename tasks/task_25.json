{
  "task_id": "CodeNet/AIZU/DSL_2_G",
  "prompt": "def range_add_range_sum(n, queries):\n    \"\"\"\n    Range Add Range Sum Query (Segment Tree with Lazy Propagation)\n\n    Implement a data structure that supports the following operations on an\n    array A of n integers, all initially set to 0:\n\n    1. add(s, t, x): Add x to all elements A[s], A[s+1], ..., A[t] (1-indexed)\n    2. getSum(s, t): Return the sum A[s] + A[s+1] + ... + A[t] (1-indexed)\n\n    This problem requires implementing a Segment Tree with Lazy Propagation\n    to achieve O(log n) time complexity for both operations.\n\n    The key insight is that when we need to update a range, we don't update\n    all individual elements. Instead, we store \"lazy\" values at segment tree\n    nodes that represent pending updates to propagate to children.\n\n    Args:\n        n: int - size of the array (1 <= n <= 100,000)\n        queries: list of tuples - each query is one of:\n            (0, s, t, x) - add x to elements from index s to t (inclusive, 1-indexed)\n            (1, s, t) - return sum of elements from index s to t (inclusive, 1-indexed)\n\n    Returns:\n        list of int - results for each getSum query (type 1)\n\n    Constraints:\n        - 1 <= n <= 100,000\n        - 1 <= q <= 100,000 (number of queries)\n        - 1 <= s <= t <= n\n        - -10,000 <= x <= 10,000\n\n    Example:\n        Input:\n            n = 3\n            queries = [\n                (0, 1, 2, 1),   # add 1 to A[1..2]: A = [1, 1, 0]\n                (0, 2, 3, 2),   # add 2 to A[2..3]: A = [1, 3, 2]\n                (0, 3, 3, 3),   # add 3 to A[3..3]: A = [1, 3, 5]\n                (1, 1, 2),      # sum A[1..2] = 1 + 3 = 4\n                (1, 2, 3)       # sum A[2..3] = 3 + 5 = 8\n            ]\n        Output: [4, 8]\n\n    Example 2:\n        Input:\n            n = 5\n            queries = [\n                (0, 1, 5, 1),   # add 1 to all: A = [1,1,1,1,1]\n                (1, 1, 5),      # sum = 5\n                (0, 2, 4, 2),   # add 2 to A[2..4]: A = [1,3,3,3,1]\n                (1, 1, 5),      # sum = 11\n                (1, 2, 4)       # sum = 9\n            ]\n        Output: [5, 11, 9]\n\n    Implementation Notes:\n        - Use a segment tree of size 4*n to be safe\n        - Each node stores: sum of its range, lazy value (pending add)\n        - Before accessing children, propagate lazy value down (push_down)\n        - After updating children, recalculate parent sum (push_up)\n        - The lazy propagation ensures O(log n) per operation\n    \"\"\"\n",
  "entry_point": "range_add_range_sum",
  "canonical_solution": "    # Segment Tree with Lazy Propagation\n    size = 1\n    while size < n:\n        size *= 2\n    \n    # tree[i] = sum of range, lazy[i] = pending add value\n    tree = [0] * (2 * size)\n    lazy = [0] * (2 * size)\n    \n    def push_down(node, node_left, node_right):\n        \"\"\"Propagate lazy value to children\"\"\"\n        if lazy[node] != 0 and node_left != node_right:\n            mid = (node_left + node_right) // 2\n            left_child = 2 * node\n            right_child = 2 * node + 1\n            \n            # Update children's lazy values\n            lazy[left_child] += lazy[node]\n            lazy[right_child] += lazy[node]\n            \n            # Update children's sums\n            tree[left_child] += lazy[node] * (mid - node_left + 1)\n            tree[right_child] += lazy[node] * (node_right - mid)\n            \n            lazy[node] = 0\n    \n    def update(node, node_left, node_right, query_left, query_right, value):\n        \"\"\"Add value to range [query_left, query_right]\"\"\"\n        if query_right < node_left or node_right < query_left:\n            return\n        \n        if query_left <= node_left and node_right <= query_right:\n            tree[node] += value * (node_right - node_left + 1)\n            lazy[node] += value\n            return\n        \n        push_down(node, node_left, node_right)\n        \n        mid = (node_left + node_right) // 2\n        update(2 * node, node_left, mid, query_left, query_right, value)\n        update(2 * node + 1, mid + 1, node_right, query_left, query_right, value)\n        \n        tree[node] = tree[2 * node] + tree[2 * node + 1]\n    \n    def query(node, node_left, node_right, query_left, query_right):\n        \"\"\"Get sum of range [query_left, query_right]\"\"\"\n        if query_right < node_left or node_right < query_left:\n            return 0\n        \n        if query_left <= node_left and node_right <= query_right:\n            return tree[node]\n        \n        push_down(node, node_left, node_right)\n        \n        mid = (node_left + node_right) // 2\n        left_sum = query(2 * node, node_left, mid, query_left, query_right)\n        right_sum = query(2 * node + 1, mid + 1, node_right, query_left, query_right)\n        \n        return left_sum + right_sum\n    \n    results = []\n    for q in queries:\n        if q[0] == 0:\n            # add(s, t, x)\n            _, s, t, x = q\n            update(1, 1, size, s, t, x)\n        else:\n            # getSum(s, t)\n            _, s, t = q\n            results.append(query(1, 1, size, s, t))\n    \n    return results\n",
  "test": "\n\nMETADATA = {\n    'author': 'aizu',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    # Official AIZU sample\n    queries1 = [\n        (0, 1, 2, 1),\n        (0, 2, 3, 2),\n        (0, 3, 3, 3),\n        (1, 1, 2),\n        (1, 2, 3)\n    ]\n    assert candidate(3, queries1) == [4, 8]\n    \n    # Single element updates and queries\n    queries2 = [\n        (0, 1, 1, 5),\n        (1, 1, 1)\n    ]\n    assert candidate(1, queries2) == [5]\n    \n    # Full range operations\n    queries3 = [\n        (0, 1, 5, 1),\n        (1, 1, 5),\n        (0, 2, 4, 2),\n        (1, 1, 5),\n        (1, 2, 4)\n    ]\n    assert candidate(5, queries3) == [5, 11, 9]\n    \n    # Multiple overlapping updates\n    queries4 = [\n        (0, 1, 4, 1),\n        (0, 2, 5, 1),\n        (0, 3, 6, 1),\n        (1, 1, 6),\n        (1, 3, 4)\n    ]\n    assert candidate(6, queries4) == [12, 6]\n    \n    # Negative values\n    queries5 = [\n        (0, 1, 3, 10),\n        (0, 2, 3, -5),\n        (1, 1, 3),\n        (1, 2, 2)\n    ]\n    assert candidate(3, queries5) == [20, 5]\n    \n    # Large range with point queries\n    queries6 = [\n        (0, 1, 10, 1),\n        (1, 5, 5),\n        (0, 5, 5, 4),\n        (1, 5, 5),\n        (1, 1, 10)\n    ]\n    assert candidate(10, queries6) == [1, 5, 14]\n    \n    # Alternating updates\n    queries7 = [\n        (0, 1, 2, 3),\n        (0, 3, 4, 3),\n        (1, 1, 4),\n        (0, 2, 3, 2),\n        (1, 1, 4)\n    ]\n    assert candidate(4, queries7) == [12, 16]\n\n"
}

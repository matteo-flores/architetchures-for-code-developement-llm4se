{ 
  "task_id": "Task10", 
  "prompt": "from typing import List, Dict, Tuple\n\n\ndef solve_graph_cycle_removal_and_max_distance(file_content: str) -> Tuple[Dict, Dict]:\n \"\"\"\n   Reads a weighted, directed, and connected graph from a string ('file_content'),\n    transforms it into a Directed Acyclic Graph (DAG) by removing the maximum\n    weight Cycle-Breaking Edge Set (of minimum cardinality), and then calculates the maximum\n    distances (longest paths) from every source node to all other reachable nodes in the resulting DAG.\n\n    The input string format is:\n    1. Integer N (number of vertices) on the first line.\n    2. N lines, each with a unique alphanumeric node ID (up to 30 chars).\n    3. Indefinite lines of triplets: <id_1> <id_2> <weight> (non-negative integer).\n\n    The overall process must implement:\n    1. **Minimum Feedback Edge Set (FES) Candidates:** Identify all sets of edges with minimum cardinality\n       whose removal makes the graph a DAG.\n    2. **DAG Construction:** Select and remove the FES candidate with the **maximum total weight**\n       (sum of weights of edges in the set).\n    3. **Maximum Distances:** In the constructed DAG, calculate the maximum distance (longest path)\n       from every source node to all other reachable nodes (using Topological Sort).\n\n    Returns:\n    - A dictionary representing the final DAG's adjacency list (Node ID -> list of (neighbor_id, weight)).\n    - A dictionary of maximum distances: {source_node_id: {target_node_id: max_distance}}.\n    \"\"\"\n    pass",
  "entry_point": "solve_graph_cycle_removal_and_max_distance",
  "canonical_solution": "",
  "test": "\n\nMETADATA = {\n    'author': 'LLM project authors',\n    'dataset': 'graph_logic'\n}\n\ndef check(candidate):\n    # TEST 1: Simple 2-node cycle (A <-> B)\n    # A->B (weight 10), B->A (weight 20)\n    # Logic: Minimum cardinality set is size 1. Candidates: {(A,B)}, {(B,A)}.\n    # Selection: Remove MAX weight -> Remove (B,A) [20].\n    # Resulting DAG: A -> B (10).\n    input_1 = \"2\\nA\\nB\\nA B 10\\nB A 20\"\n    adj_1, dist_1 = candidate(input_1)\n    \n    # Check that B->A is removed (not in adjacency of B)\n    # Note: access safely as keys might not exist if empty list is not initialized\n    b_neighbors = [n[0] for n in adj_1.get('B', [])]\n    assert 'A' not in b_neighbors, \"Failed Test 1: Heavy edge B->A should be removed.\"\n    \n    # Check that A->B remains\n    a_neighbors = adj_1.get('A', [])\n    assert ('B', 10) in a_neighbors or ['B', 10] in a_neighbors, \"Failed Test 1: Light edge A->B should remain.\"\n    \n    # Check Distances: Source is A. A->B is 10.\n    assert dist_1['A']['B'] == 10, \"Failed Test 1: Distance calculation wrong.\"\n\n    # TEST 2: Triangle Cycle (X -> Y -> Z -> X)\n    # X->Y (5), Y->Z (5), Z->X (100)\n    # Remove Z->X (100) because it's the heaviest in the cycle.\n    # DAG: X -> Y -> Z\n    input_2 = \"3\\nX\\nY\\nZ\\nX Y 5\\nY Z 5\\nZ X 100\"\n    adj_2, dist_2 = candidate(input_2)\n    \n    # Check edge removal\n    z_neighbors = [n[0] for n in adj_2.get('Z', [])]\n    assert 'X' not in z_neighbors, \"Failed Test 2: Heaviest edge Z->X should be removed.\"\n    \n    # Check Longest Path from Source (X)\n    # X -> Y (5) -> Z (5) = Total 10\n    assert dist_2['X']['Y'] == 5, \"Failed Test 2: Distance X->Y wrong.\"\n    assert dist_2['X']['Z'] == 10, \"Failed Test 2: Distance X->Z wrong.\"\n\n    # TEST 3: No Cycle (Already DAG)\n    # S -> A (10), S -> B (20)\n    # Nothing should be removed.\n    input_3 = \"3\\nS\\nA\\nB\\nS A 10\\nS B 20\"\n    adj_3, dist_3 = candidate(input_3)\n    \n    s_neighbors = adj_3.get('S', [])\n    assert len(s_neighbors) == 2, \"Failed Test 3: No edges should be removed in a DAG.\"\n    \n    assert dist_3['S']['A'] == 10\n    assert dist_3['S']['B'] == 20\n"
}
